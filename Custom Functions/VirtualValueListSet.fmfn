/**
 *******************************************************************************
 * VirtualValueListSet ( displayList ; idList ; valueListID )
 *
 * PURPOSE:
 *		Sets a virtual value list with a specified series of return-delimited
 *		values. This function works in connection with a value list defined to
 *		be based on an unstored calculation that references the global variables
 *		set by this function.
 *
 * RETURNS: "" (null)
 *
 * PARAMETERS:
 *		displayList: A return-delimited list of values to display, in the order
 *		they are to be displayed. Clears the value list when left empty.
 *		idList: (optional) A return-delimited list of values to set from the
 *		value list, but not display, in matching order with displayList.
 *		valueListID: (optional) The unique (numeric) ID of the dynamic value
 *		list to address. It is the responsibility of the solution developer to
 *		devise and adhere to a consistent ID scheme. Defaults to 1.
 *
 * DEPENDENCIES: none
 *
 * VARIABLES:
 *		$$~VirtualValueList.DISPLAY_LIST[n]
 *		$$~VirtualValueList.ID_LIST[n]
 *
 * NOTES:
 *		This module is based on techniques demonstrated by John Ahn,
 *		Andries Heylen, and Marcelo Piñeyro.
 *
 * HISTORY:
 *		CREATED on 2013-05-06 by Jeremy Bante <http://scr.im/jbante>.
 *
 * REFERENCES:
 *		http://www.filemakerhacks.com/?p=5357
 *		http://www.filemakerhacks.com/?p=5412
 *		http://www.soliantconsulting.com/blog/2012/09/extending-filemaker-pro’s-value-list-sort-capabilities-using-char-function
 *******************************************************************************
 */

Case (
	/* Step 0, set-up */
	not $~vvl.step ;
		Let ( [
			~valueListID =
				If ( IsEmpty ( valueListID ) ; 1 ; /* Else */ valueListID ) ;
			$$~VirtualValueList.DISPLAY_LIST[~valueListID] = "" ;
			$~vvl.valueCount = ValueCount ( displayList ) ;
			$~vvl.nonBreakingSpace = Char ( 65279 ) ;
			$~vvl.step = 1
		] ;
			VirtualValueListSet ( displayList ; idList ; ~valueListID )
		) ;

	/* Step 1, append non-breaking spaces to line starts to coerce sort order */
	$~vvl.step = 1 ;
		Let ( [
			$~vvl.i = $~vvl.i + 1 ;
			$$~VirtualValueList.DISPLAY_LIST[valueListID] =
				If ( $~vvl.i > 1 ;
					$$~VirtualValueList.DISPLAY_LIST[valueListID] & ¶
				)
				& $~vvl.prefix
				& GetValue ( displayList ; $~vvl.i ) ;
			$~vvl.prefix = $~vvl.prefix & $~vvl.nonBreakingSpace ;
			$~vvl.step =
				If ( $~vvl.i < $~vvl.valueCount ;
					$~vvl.step ;
					/* Else */ $~vvl.step + 1
				)
		] ;
			VirtualValueListSet ( displayList ; idList ; valueListID )
		) ;

	/* Step 2, clean-up and return result */
	$~vvl.step = 2 ;
		Let ( [
			$$~VirtualValueList.ID_LIST[valueListID] =
				If ( not IsEmpty ( idList ) and $~vvl.valueCount > 0 ; idList ) ;

			// purge variables
			$~vvl.i = "" ;
			$~vvl.nonBreakingSpace = "" ;
			$~vvl.prefix = "" ;
			$~vvl.step = "" ;
			$~vvl.valueCount = ""
		] ;
			""
		)
)